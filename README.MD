# Отчёты по лабораторной работе №2:    
1) [Умножение матрицы на вектор с помощью MPI](#1-Умножение-матрицы-на-вектор-с-помощью-MPI)
2) [Матричное умножение по алгоритму Кэннона](#2-матричное-умножение-по-алгоритму-кэннона)
## 1. Умножение матрицы на вектор с помощью MPI  
1) [Алгоритм](#Пошаговый-алгоритм-работы-программы-1)
2) [Сборка](#Сборка-1)
3) [Запуск](#Запуск-1)
4) [Графики](#Графики-1)
### Пошаговый алгоритм работы программы 1   
1. Инициализация MPI    
    1. MPI_Init запускает MPI, позволяя использовать процессы.    
    2. Узнаются:    
        * Ранг текущего процесса (rank).
        * Общее число процессов (size).
2. Чтение входных параметров    
    1. Программа принимает три аргумента командной строки:
        * rows — количество строк в матрице.
        * cols — количество столбцов в матрице.
    2. Если аргументы не указаны или указаны неверно, программа завершает выполнение (на процессе с рангом 0 выводится сообщение об ошибке).
3. Инициализация данных    
    * Матрица (matrix) размером rows × cols заполняется единицами.
    * Вектор (vector) длиной cols заполняется единицами.
    * Результирующий вектор (result) длиной rows изначально заполняется нулями.
4. Разбиение и выполнение алгоритмов
    1. Подход 1: Разбиение по строкам
        1) Каждый процесс обрабатывает строки матрицы, индексы которых соответствуют rank, rank + size, rank + 2*size и так далее.
        2) Для каждой строки:
            * Вычисляется сумма произведений элементов строки на элементы вектора.
            * Результат сохраняется в локальный результат (result).
        3) Локальные результаты всех процессов объединяются через MPI_Reduce с операцией суммирования.
    2. Подход 2: Разбиение по столбцам
        1) Каждый процесс обрабатывает столбцы матрицы с индексами rank, rank + size, rank + 2*size и так далее.
        2) Для каждого столбца:
            * Вычисляется частичный результат, добавляющий вклад столбца в строки результирующего вектора.
        3) Частичные результаты всех процессов суммируются через MPI_Reduce.
    3. Подход 3: Разбиение на блоки
        1) Матрица делится на блоки строк, и каждый процесс обрабатывает свой блок.
        2) Процесс обрабатывает свои строки, как в подходе по строкам.
        3) Результаты объединяются через MPI_Reduce.
5. Измерение времени
    1) Каждый подход передаётся в функцию measure_algorithm_time, которая:
        1. Замеряет начальное время через MPI_Wtime.
        2. Вызывает переданный алгоритм.
        3. Замеряет конечное время и возвращает разницу.
6. Вывод результатов
    1. Только процесс с рангом 0 выводит:
        1) Время выполнения для каждого подхода:
            * Разбиение по строкам.
            * Разбиение по столбцам.
            * Разбиение на блоки.
7. Завершение работы
    1) Освобождаются ресурсы MPI через MPI_Finalize.
    2) Программа завершает выполнение.

### Сборка 1
    mpicxx -o First.exe First.cpp

### Запуск 1
    mpirun -np <num_processes> ./First.exe <rows> <cols>    
Пример:    
    mpirun -np 4 ./First.exe 10000 10000    

### Графики 1

## 2. Матричное умножение по алгоритму Кэннона
1) [Алгоритм](#Пошаговый-алгоритм-работы-программы-2)
2) [Сборка](#Сборка-2)
3) [Запуск](#Запуск-2)
4) [Графики](#Графики-2)
### Пошаговый алгоритм работы программы 2
1. Инициализация MPI и процессов:    
    * Все процессы запускаются через MPI_Init.
    * Создается решетка процессов (2D-сетка) с помощью MPI_Cart_create, где процессы организуются в  $\sqrt{p}$ * $\sqrt{p}$    
2. Инициализация матриц:    
    * Матрицы A и B инициализируются случайными значениями на главном процессе (ранг 0).
    * Для каждого процесса выделяются локальные блоки матриц A, B, и результирующей матрицы C размером blockSize×blockSize.
3. Распределение данных:
    * Главный процесс разрезает глобальные матрицы на блоки и отправляет их процессам.
    * Каждый процесс получает свои блоки матриц A и B для вычислений.
4. Инициализация циклического сдвига (по алгоритму Кэннона):
    * Сдвиг блоков: Блоки матрицы A сдвигаются влево на coords[0], а блоки матрицы B — вверх на coords[1], где coords — координаты процесса в сетке.
    * Это обеспечивает начальную настройку для корректного выполнения умножения блоков.
5. Основной цикл умножения:
    * Алгоритм выполняет $\sqrt{p}$ шагов:
        1. Перемножение текущих блоков A и B.
        2. Сдвиг блоков A влево и B вверх.
    * Для передачи блоков используется MPI_Sendrecv_replace.
6. Сбор результата:
    * После завершения цикла каждый процесс отправляет свои блоки результирующей матрицы C главному процессу.
    * Главный процесс собирает глобальную матрицу C из всех блоков.
7. Замеры времени:
    * Время выполнения основного цикла замеряется с помощью MPI_Wtime().
    * Главный процесс выводит время выполнения на экран.
8. Завершение программы:
    1) Освобождаются ресурсы MPI через MPI_Finalize.
    2) Программа завершает выполнение.

### Сборка 2
    mpicxx -o First.exe First.cpp

### Запуск 2
    mpirun -np <num_processes> ./Second.exe <size_of_matrix>    
Пример:    
    mpirun -np 4 ./Second.exe 1024     
* Уточнения:
    1) Количество процессов должно быть квадратом числа(1,4,9,16...)
    2) Размер матрицы должен быть кратен корню из количества процессов

### Графики 2